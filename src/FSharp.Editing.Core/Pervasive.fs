[<AutoOpen>]
module FSharp.Editing.Pervasive

open System
open System.IO
open System.Diagnostics
open System.Text.RegularExpressions
open System.Threading
open Microsoft.FSharp.Compiler.SourceCodeServices

/// Right Associative Backpipe Operator (<|)
let (^) = (<|) 

/// Path.Combine
let (</>) path1 path2 = Path.Combine (path1, path2)

/// Newline String defined for this Environment
let envNewLine = System.Environment.NewLine

/// Null coalescing operator, return non null a, otherwise b
let (?|?) a b = if isNull a then b else a


/// OR predicate combinator
let inline (|?|) (pred1:'a->bool) (pred2:'a->bool)  =
    fun a -> pred1 a || pred2 a

/// AND predicate combinator
let inline (|&|) (pred1:'a->bool) (pred2:'a->bool)  =
    fun a -> pred1 a && pred2 a

/// If arg is null raise an `ArgumentNullException` with the argname
let inline checkNullArg arg argName = if isNull arg then nullArg argName

/// Throw a System.InvalidArgument exception with a Printf message
let invalidArgf arg msg =  Printf.kprintf (invalidArg arg) msg


/// obj.ReferenceEquals
let inline (==) a b = obj.ReferenceEquals(a, b)
/// LanguagePrimitives.PhysicalEquality
let inline (===) a b = LanguagePrimitives.PhysicalEquality a b
let inline debug msg = Printf.kprintf Debug.WriteLine msg

// Redirect debug output to F# Interactive for debugging purpose.
// It requires adding '-d:DEBUG' setting in F# Interactive Options.
#if INTERACTIVE
Debug.Listeners.Add(new TextWriterTraceListener(System.Console.Out)) |> ignore
Debug.AutoFlush <- true
#endif


let inline incr (counter: ^a byref) = 
    counter <- LanguagePrimitives.GenericOne< ^a> + counter

let inline decr (counter: ^a byref) = 
    counter <- counter - LanguagePrimitives.GenericOne< ^a> 


let inline fail msg = Printf.kprintf Debug.Fail msg
let inline isNotNull v = not ^ isNull v
let inline dispose (disposable:#IDisposable) = disposable.Dispose ()

let inline Ok a = Choice1Of2 a
let inline Fail a = Choice2Of2 a
let inline (|Ok|Fail|) a = a

/// String Equals Ordinal Ignore Case
let (|EqualsIC|_|) (str : string) arg =
    if String.Compare(str, arg, StringComparison.OrdinalIgnoreCase) = 0 then Some()
    else None

let getEnvInteger e defaultValue = 
    match System.Environment.GetEnvironmentVariable e with 
    | null -> defaultValue 
    | t -> try int t with _ -> defaultValue

let tryCast<'T> (o: obj): 'T option = 
    match o with
    | null -> None
    | :? 'T as a -> Some a
    | _ -> 
        debug "Cannot cast %O to %O" (o.GetType()) typeof<'T>.Name
        None

let inline liftAsync (computation : Async<'T>) : Async<'T option> = async {
    let! a = computation
    return Some a 
}

/// Load times used to reset type checking properly on script/project load/unload. It just has to be unique for each project load/reload.
/// Not yet sure if this works for scripts.
let fakeDateTimeRepresentingTimeLoaded x = DateTime(abs (int64 (match x with null -> 0 | _ -> x.GetHashCode())) % 103231L)
    
open System.Threading


let synchronize f = 
    let ctx = SynchronizationContext.Current
        
    let thread = 
        match ctx with
        | null -> null // saving a thread-local access
        | _ -> Thread.CurrentThread
    f ^ fun g arg -> 
        let nctx = SynchronizationContext.Current
        match ctx, nctx with
        | null, _ -> g arg
        | _, _ when Object.Equals(ctx, nctx) && thread.Equals Thread.CurrentThread -> g arg
        | _ -> ctx.Post ((fun _ -> g arg), null)


let memoize f =
    let cache = System.Collections.Generic.Dictionary()
    fun x ->
        match cache.TryGetValue x with
        | true, x -> x
        | _ -> let res = f x in cache.[x] <- res; res


let isSymbolLocalForProject (symbol: FSharpSymbol) = 
    match symbol with 
    | :? FSharpParameter -> true
    | :? FSharpMemberOrFunctionOrValue as m -> not m.IsModuleValueOrMember || not m.Accessibility.IsPublic
    | :? FSharpEntity as m -> not m.Accessibility.IsPublic
    | :? FSharpGenericParameter -> true
    | :? FSharpUnionCase as m -> not m.Accessibility.IsPublic
    | :? FSharpField as m -> not m.Accessibility.IsPublic
    | _ -> false

let inline private attempt (f: unit -> 'T) = try Some <| f() with _ -> None

let isAttribute<'T> (attribute: FSharpAttribute) =
    // CompiledName throws exception on DataContractAttribute generated by SQLProvider
    match attempt (fun _ -> attribute.AttributeType.CompiledName) with
    | Some name when name = typeof<'T>.Name -> true
    | _ -> false

let hasAttribute<'T> (attributes: seq<FSharpAttribute>) =
    attributes |> Seq.exists isAttribute<'T>

let tryGetAttribute<'T> (attributes: seq<FSharpAttribute>) =
    attributes |> Seq.tryFind isAttribute<'T>
        
let hasModuleSuffixAttribute (entity: FSharpEntity) = 
        entity.Attributes
        |> tryGetAttribute<CompilationRepresentationAttribute>
        |> Option.bind (fun a -> 
            attempt (fun _ -> a.ConstructorArguments)
            |> Option.bind (fun args -> args |> Seq.tryPick (fun (_, arg) ->
                let res =
                    match arg with
                    | :? int32 as arg when arg = int CompilationRepresentationFlags.ModuleSuffix -> 
                        Some() 
                    | :? CompilationRepresentationFlags as arg when arg = CompilationRepresentationFlags.ModuleSuffix -> 
                        Some() 
                    | _ -> 
                        None
                res)))
        |> Option.isSome

let isOperator (name: string) =
    name.StartsWith "( " && name.EndsWith " )" && name.Length > 4
        && name.Substring (2, name.Length - 4) 
            |> String.forall (fun c -> c <> ' ' && not (Char.IsLetter c))

let private UnnamedUnionFieldRegex = Regex("^Item(\d+)?$", RegexOptions.Compiled)
let isUnnamedUnionCaseField (field: FSharpField) = UnnamedUnionFieldRegex.IsMatch(field.Name)

type FileName = string
type FilePath = string

//
//[<RequireQualifiedAccess>]
//module Point =
//    open Microsoft.FSharp.Compiler.Range
//    
//    let inline make0idx line column = Pos.fromZ line column
//    let inline make1idx line column = Pos.fromZ line column |> Pos.toZ
//
//[<RequireQualifiedAccess>]
//module Range =
//    open Microsoft.FSharp.Compiler
//
//    let make startLine startColumn endLine endColumn  =
//        Range.    
//
//        { Start = Point.make startLine startColumn
//          End = Point.make endLine endColumn }
//    
//type CurrentLine<[<Measure>]'t> = 
//    { Line: string
//      File: FileName; Range: Range<'t> }
//    member x.EndLine = x.Range.End.Line 
//
//[<NoComparison>]
//type PointInDocument<[<Measure>]'t> = 
//    { Point: Point<'t>
//      Line: string
//      Document: string
//      File: FileName }
//    member x.LineIndex = x.Point.Line
//    member x.ColumnIndex = x.Point.Column
//    member x.CurrentLine : Lazy<CurrentLine<'t>> = 
//        lazy
//          { Line = x.Line
//            File = x.File
//            Range = Range.make x.LineIndex x.ColumnIndex x.LineIndex x.Line.Length }
//

type Atom<'T when 'T: not struct>(value: 'T) = 
    let refCell = ref value
        
    let rec swap f = 
        let currentValue = !refCell
        let result = Interlocked.CompareExchange<'T>(refCell, f currentValue, currentValue)
        if obj.ReferenceEquals(result, currentValue) then result
        else 
            SpinWait.SpinUntil((fun _ ->false),20) |> ignore
            swap f
        
    member __.Value = !refCell
    member __.Swap (f: 'T -> 'T) = swap f   

open System.Text
open System.Diagnostics

type Profiler () =
    let measures = ResizeArray()
    let total = Stopwatch.StartNew()

    member __.Time msg f = 
        let sw = Stopwatch.StartNew()
        let res = f() in measures.Add (msg, sw.Elapsed); res

    member __.TimeAsync msg f = async {
        let sw = Stopwatch.StartNew()
        let! res = f() in measures.Add (msg, sw.Elapsed); return res 
    }

    member __.Stop() = total.Stop()
    
    member __.Result =
        let measurestr = 
            measures 
            |> Seq.groupBy ^ fun (msg, _) -> msg
            |> Seq.map ^ fun (msg, ts) -> 
                msg, TimeSpan.FromTicks (ts |> Seq.sumBy ^ fun (_, t) -> t.Ticks)
            |> Seq.sortBy ^ fun (_, t) -> -t
            |> Seq.fold (fun (acc: StringBuilder) (msg, t) -> 
                acc.AppendLine (sprintf "%s, %O" msg t)) (StringBuilder())
            |> string
        sprintf
            "\nTotal = %O\n%s" total.Elapsed measurestr

    member __.Elapsed = total.Elapsed        

/// Assert helpers
type Assert() = 
    /// Display a good exception for this error message and then rethrow.
    static member Exception(e:Exception) =  
        System.Diagnostics.Debug.Assert(false, "Unexpected exception seen in language service", e.ToString())
       


      
/// Maybe computation expression builder, copied from ExtCore library
/// https://github.com/jack-pappas/ExtCore/blob/master/ExtCore/Control.fs
[<Sealed>]
type MaybeBuilder () =
    // 'T -> M<'T>
    [<DebuggerStepThrough>]
    member inline __.Return value: 'T option = Some value

    // M<'T> -> M<'T>
    [<DebuggerStepThrough>]
    member inline __.ReturnFrom value: 'T option = value

    // unit -> M<'T>
    [<DebuggerStepThrough>]
    member inline __.Zero (): unit option = Some ()     // TODO: Should this be None?

    // (unit -> M<'T>) -> M<'T>
    [<DebuggerStepThrough>]
    member __.Delay (f: unit -> 'T option): 'T option = f ()

    // M<'T> -> M<'T> -> M<'T>
    // or
    // M<unit> -> M<'T> -> M<'T>
    [<DebuggerStepThrough>]
    member inline __.Combine (r1, r2: 'T option): 'T option =
        match r1 with
        | None -> None
        | Some () -> r2

    // M<'T> * ('T -> M<'U>) -> M<'U>
    [<DebuggerStepThrough>]
    member inline __.Bind (value, f: 'T -> 'U option): 'U option = Option.bind f value

    // 'T * ('T -> M<'U>) -> M<'U> when 'U :> IDisposable
    [<DebuggerStepThrough>]
    member __.Using (resource: ('T :> System.IDisposable), body: _ -> _ option): _ option =
        try body resource
        finally if not <| obj.ReferenceEquals (null, box resource) then resource.Dispose ()

    // (unit -> bool) * M<'T> -> M<'T>
    [<DebuggerStepThrough>]
    member x.While (guard, body: _ option): _ option =
        if guard () then
            // OPTIMIZE: This could be simplified so we don't need to make calls to Bind and While.
            x.Bind (body, (fun () -> x.While (guard, body)))
        else x.Zero ()

    // seq<'T> * ('T -> M<'U>) -> M<'U>
    // or
    // seq<'T> * ('T -> M<'U>) -> seq<M<'U>>
    [<DebuggerStepThrough>]
    member x.For (sequence: seq<_>, body: 'T -> unit option): _ option =
        // OPTIMIZE: This could be simplified so we don't need to make calls to Using, While, Delay.
        x.Using (sequence.GetEnumerator (), fun enum ->
            x.While (enum.MoveNext,
                x.Delay (fun () -> body enum.Current)
            )
        )

let maybe = MaybeBuilder()

[<Sealed>]
type AsyncMaybeBuilder () =
    [<DebuggerStepThrough>]
    member __.Return value : Async<'T option> = Some value |> async.Return

    [<DebuggerStepThrough>]
    member __.ReturnFrom value : Async<'T option> = value

    [<DebuggerStepThrough>]
    member __.ReturnFrom (value: 'T option) : Async<'T option> = async.Return value

    [<DebuggerStepThrough>]
    member __.Zero () : Async<unit option> = Some () |> async.Return

    [<DebuggerStepThrough>]
    member __.Delay (f : unit -> Async<'T option>) : Async<'T option> = async.Delay f

    [<DebuggerStepThrough>]
    member __.Combine (r1, r2 : Async<'T option>) : Async<'T option> = async {
        let! r1' = r1
        match r1' with
        | None -> return None
        | Some () -> return! r2
    }

    [<DebuggerStepThrough>]
    member __.Bind (value: Async<'T option>, f : 'T -> Async<'U option>) : Async<'U option> = async {
        let! value' = value
        match value' with
        | None -> return None
        | Some result -> return! f result
    }

    [<DebuggerStepThrough>]
    member __.Bind (value: System.Threading.Tasks.Task<'T>, f : 'T -> Async<'U option>) : Async<'U option> = async {
        let! value' = Async.AwaitTask value
        return! f value'
    }

    [<DebuggerStepThrough>]
    member __.Bind (value: 'T option, f : 'T -> Async<'U option>) : Async<'U option> = async {
        match value with
        | None -> return None
        | Some result -> return! f result
    }

    [<DebuggerStepThrough>]
    member __.Using (resource : ('T :> IDisposable), body : _ -> Async<_ option>) : Async<_ option> =
        try body resource
        finally if not (isNull resource) then resource.Dispose ()

    [<DebuggerStepThrough>]
    member x.While (guard, body : Async<_ option>) : Async<_ option> =
        if guard () then x.Bind (body, (fun () -> x.While (guard, body)))
        else x.Zero ()

    [<DebuggerStepThrough>]
    member x.For (sequence : seq<_>, body : 'T -> Async<unit option>) : Async<_ option> =
        x.Using (sequence.GetEnumerator (), fun enum ->
            x.While (enum.MoveNext, 
                x.Delay (fun () -> body enum.Current)
            )
        )

    [<DebuggerStepThrough>]
    member inline __.TryWith (computation : Async<'T option>, catchHandler : exn -> Async<'T option>) : Async<'T option> =
        async.TryWith (computation, catchHandler)

    [<DebuggerStepThrough>]
    member inline __.TryFinally (computation : Async<'T option>, compensation : unit -> unit) : Async<'T option> =
        async.TryFinally (computation, compensation)

let asyncMaybe = AsyncMaybeBuilder()


